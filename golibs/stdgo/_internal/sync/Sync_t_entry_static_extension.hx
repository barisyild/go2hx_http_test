package stdgo._internal.sync;
@:keep @:allow(stdgo._internal.sync.Sync.T_entry_asInterface) class T_entry_static_extension {
    @:keep
    @:tdfield
    static public function _tryExpungeLocked( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>):Bool throw "T_entry:sync._tryExpungeLocked is not yet implemented";
    @:keep
    @:tdfield
    static public function _trySwap( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>, _i:stdgo.Pointer<stdgo.AnyInterface>):{ var _0 : stdgo.Pointer<stdgo.AnyInterface>; var _1 : Bool; } throw "T_entry:sync._trySwap is not yet implemented";
    @:keep
    @:tdfield
    static public function _delete( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>):{ var _0 : stdgo.AnyInterface; var _1 : Bool; } throw "T_entry:sync._delete is not yet implemented";
    @:keep
    @:tdfield
    static public function _tryLoadOrStore( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>, _i:stdgo.AnyInterface):{ var _0 : stdgo.AnyInterface; var _1 : Bool; var _2 : Bool; } throw "T_entry:sync._tryLoadOrStore is not yet implemented";
    @:keep
    @:tdfield
    static public function _swapLocked( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>, _i:stdgo.Pointer<stdgo.AnyInterface>):stdgo.Pointer<stdgo.AnyInterface> throw "T_entry:sync._swapLocked is not yet implemented";
    @:keep
    @:tdfield
    static public function _unexpungeLocked( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>):Bool throw "T_entry:sync._unexpungeLocked is not yet implemented";
    @:keep
    @:tdfield
    static public function _tryCompareAndSwap( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>, _old:stdgo.AnyInterface, _new_:stdgo.AnyInterface):Bool throw "T_entry:sync._tryCompareAndSwap is not yet implemented";
    @:keep
    @:tdfield
    static public function _load( _e:stdgo.Ref<stdgo._internal.sync.Sync_t_entry.T_entry>):{ var _0 : stdgo.AnyInterface; var _1 : Bool; } throw "T_entry:sync._load is not yet implemented";
}
