package stdgo._internal.sync.atomic_;
@:keep @:allow(stdgo._internal.sync.atomic_.Atomic_.Uintptr_asInterface) class Uintptr_static_extension {
    @:keep
    @:tdfield
    static public function add( _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr>, _delta:stdgo.GoUIntptr):stdgo.GoUIntptr {
        @:recv var _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr> = _x;
        trace("funclit");
        throw "not implemented: add";
    }
    @:keep
    @:tdfield
    static public function compareAndSwap( _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr>, _old:stdgo.GoUIntptr, _new_:stdgo.GoUIntptr):Bool {
        @:recv var _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr> = _x;
        trace("funclit");
        throw "not implemented: compareAndSwap";
    }
    @:keep
    @:tdfield
    static public function swap( _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr>, _new_:stdgo.GoUIntptr):stdgo.GoUIntptr {
        @:recv var _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr> = _x;
        trace("funclit");
        throw "not implemented: swap";
    }
    @:keep
    @:tdfield
    static public function store( _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr>, _val:stdgo.GoUIntptr):Void {
        @:recv var _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr> = _x;
    }
    @:keep
    @:tdfield
    static public function load( _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr>):stdgo.GoUIntptr {
        @:recv var _x:stdgo.Ref<stdgo._internal.sync.atomic_.Atomic__uintptr.Uintptr> = _x;
        trace("funclit");
        throw "not implemented: load";
    }
}
