package stdgo._internal.crypto.elliptic;
@:keep @:allow(stdgo._internal.crypto.elliptic.Elliptic.CurveParams_asInterface) class CurveParams_static_extension {
    @:keep
    @:tdfield
    static public function scalarBaseMult( _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams>, _k:stdgo.Slice<stdgo.GoUInt8>):{ var _0 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; var _1 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; } {
        @:recv var _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams> = _curve;
        trace("funclit");
        throw "not implemented: scalarBaseMult";
    }
    @:keep
    @:tdfield
    static public function scalarMult( _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams>, bx:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, by:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, _k:stdgo.Slice<stdgo.GoUInt8>):{ var _0 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; var _1 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; } {
        @:recv var _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams> = _curve;
        trace("funclit");
        throw "not implemented: scalarMult";
    }
    @:keep
    @:tdfield
    static public function double( _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams>, _x1:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, _y1:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>):{ var _0 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; var _1 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; } {
        @:recv var _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams> = _curve;
        trace("funclit");
        throw "not implemented: double";
    }
    @:keep
    @:tdfield
    static public function add( _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams>, _x1:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, _y1:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, _x2:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, _y2:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>):{ var _0 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; var _1 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; } {
        @:recv var _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams> = _curve;
        trace("funclit");
        throw "not implemented: add";
    }
    @:keep
    @:tdfield
    static public function isOnCurve( _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams>, _x:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, _y:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>):Bool {
        @:recv var _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams> = _curve;
        trace("funclit");
        throw "not implemented: isOnCurve";
    }
    @:keep
    @:tdfield
    static public function params( _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams>):stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams> {
        @:recv var _curve:stdgo.Ref<stdgo._internal.crypto.elliptic.Elliptic_curveparams.CurveParams> = _curve;
        trace("funclit");
        throw "not implemented: params";
    }
}
